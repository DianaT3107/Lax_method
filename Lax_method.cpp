#include <iostream>
#include <vector>
#include <fstream>

using namespace std;

vector <double> un, un1; // массивы значений искомой функции в узлах сетки в моменты времени t и t+dt соответственно
vector <double> x; // массив узлов координат сетки

double a = 0, b = 1; //координаты левой и правой границ расчётной области соответственно
double v = 1; // скорость переноса
double C = 0.9; // число Куранта
double t_stop = 1; // момент окончание расчёта
double dx; //размер ячейки сетки
double dt; // величина шага по времени
double t = 0; // текущее время

int N = 40; // количество узлов сетки

void InitializeParameters();
void Allocate();
void InitializeGrid();
double U0(const double x);
void SetIC();
void Step();
void UpdateIC();
void SaveData();
void SetBC();

int main()
{
	InitializeParameters(); //чтение/ установка параметров модели
	Allocate(); //выделение памяти динамическим массивам
	InitializeGrid(); // инициализация пространственной сетки
	SetIC(); // установка начального условия

	while (t <= t_stop)
	{
		SetBC(); //установка граничного условия
		Step(); // шаг по времени: вычисление значений искомой функции на новом временном слое
		UpdateIC(); //обновление начального условия

		t += dt; // обновление счётчика времени
	}

	for (size_t i = 0; i < x.size(); i++)
	{
		cout << un[i] << endl;
	};

	SaveData();
	return 0;

}

void InitializeParameters()
{
    a = 0;
	b = 1;
	v = 1;
	t_stop = 0.2;
	C = 1;
	N = 320;
}

 void Allocate()
 { //все массивы имеют размер N, соответствующий числу узлов сетки
	 un.resize(N);
	 un1.resize(N);
	 x.resize(N);
 }

 void InitializeGrid()
 {
	 dx = (b - a) / (N - 1); //вычисление пространственного шага по заданному числу
	 dt = C * dx / v; //вычисление шага по времени исходя из условия устойчивости
	 x[0] = a; // нулевой узел - левая граница расчётной области
	 for (int i = 1; i < N; i++)
		 x[i] = x[i - 1] + dx; //цикл рассчёта координат остальных узлов, узлы сетки распределены равномерно с шагом dx
 }

 double U0(const double x)
 {
	 if (x < 0.4)
		 return 0.4;
	if (x <= 0.6)
		 return 0.8;
	 if (x > 0.6)
		 return 0.4;

 }

 void SetIC()
 {
	 t = 0; // инициальзация счётчика времени
	 for (int i = 0; i < N; i++)
		 un[i] = U0(x[i]); //заполнение массивы un начальными значениями
 }

 void SetBC()
 {//используются формулы, соответствующие периодическим граничным условиям
	 un1[0] = 0.5 * (un[1] + un[N-2]) - C*0.5 * (un[1] - un[N-2]);
	 un1[N-1] = 0.5 * (un[1] + un[N-2]) - C*0.5 * (un[1] - un[N-2]);
 }

 void Step()
 { /*цикл расчёта значений искомой функции в узлах сетки по схеме Лакса, для v > 0.
   Значения в крайних точках, u[0] и  u[N-1}, исключены т.к. они определяются из граничных условий*/
	 for (int i = 1; i < N-1; i++)
	{
		 	 un1[i] = 0.5 * (un[i + 1] + un[i - 1]) - (v * dt) / dx * 0.5 * (un[i + 1] - un[i - 1]);
	}
 }

 void UpdateIC()
 { //в качестве начального условия для следующего шага по времени используется решение на текущем шаге
	 for (int i = 0; i < N; i++)
		 un[i] = un1[i];
 }


 void SaveData()
 {
	 ofstream f; //переменная связываемая с файловым потоком ввода
	 f.open("(results).txt", ios::out); //открытие файла с именем results.dat на запись
	 if (!f) // вывод сообщения об ошибке в случае, если поток не удалось открыть
		 cout << "unable to open file for writing" << endl;

	 f << "#x    u\n"; // первая строка файла содержит названия столбцов

	 /*цикл вывоа значений координат узлов сетки, xs, в первый столбец и соответствующий значений сеточной функции,
	 un1, во второй столбец. В качестве разделителя используется пробел*/
	 for (size_t i = 0; i < x.size(); i++)
	 {
		 f << x[i] << "    ";
		 f << un[i] << endl;
	 };

	 f.close();
}
